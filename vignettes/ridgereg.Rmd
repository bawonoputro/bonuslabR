---
title: "Ridge Regression Demo on iris"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Ridge Regression Demo on iris}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

library(regression)

library(caret)
library(dplyr)
library(stats)

set.seed(123)
```
## Data Used in Ridge Regression and QR Regression
```{r}

head(iris)

rmse <- function(truth, pred){
  sqrt(mean((truth - pred)^2))
}

```
## Train-test split for regression 
```{r}

iris_clean <- na.omit(iris)

set.seed(123)
train_idx <- caret::createDataPartition(
  iris_clean$Petal.Length,
  p = 0.8,
  list = FALSE
)

iris_train <- iris_clean[train_idx, ]
iris_test  <- iris_clean[-train_idx, ]

full_formula <- Petal.Length ~ Sepal.Length + Sepal.Width + Petal.Width + Species
full_formula

dim(iris_train)
dim(iris_test)
```
# =====================================================
# Standard Ridge Regression
```{r}
kfold_ridge_cv <- function(formula, data, lambdas, k = 10){
  set.seed(123)
  folds <- caret::createFolds(
    data$Petal.Length,
    k = k,
    list = TRUE,
    returnTrain = FALSE
  )

  results <- data.frame(
    lambda    = lambdas,
    mean_rmse = NA_real_
  )

  for(li in seq_along(lambdas)){
    lam <- lambdas[li]
    rmse_fold <- numeric(length(folds))

    for(fi in seq_along(folds)){
      valid_idx <- folds[[fi]]
      train_idx <- setdiff(seq_len(nrow(data)), valid_idx)

      train_fold <- data[train_idx, , drop = FALSE]
      valid_fold <- data[valid_idx, , drop = FALSE]

      ridge_fit <- ridgereg(
        formula = formula,
        data    = train_fold,
        lambda  = lam
      )

      pred_valid <- predict(ridge_fit, newdata = valid_fold)

      rmse_fold[fi] <- rmse(valid_fold$Petal.Length, pred_valid)
    }

    results$mean_rmse[li] <- mean(rmse_fold)
  }

  results
}

lambda_grid <- c(0, 0.01, 0.1, 1, 5, 10, 25, 50, 100)

cv_results <- kfold_ridge_cv(
  formula  = full_formula,
  data     = iris_train,
  lambdas  = lambda_grid,
  k        = 10
)

cv_results

best_row    <- cv_results[ which.min(cv_results$mean_rmse), ]
best_lambda <- best_row$lambda

best_lambda
best_row

ridge_best <- ridgereg(
  formula = full_formula,
  data    = iris_train,
  lambda  = best_lambda
)

print(ridge_best)
coef(ridge_best)

ridge_train_pred <- predict(ridge_best, newdata = iris_train)
ridge_test_pred  <- predict(ridge_best, newdata = iris_test)

ridge_train_rmse <- rmse(iris_train$Petal.Length, ridge_train_pred)
ridge_test_rmse  <- rmse(iris_test$Petal.Length,  ridge_test_pred)

ridge_train_rmse
ridge_test_rmse

```
# =====================================================
# QR-based ridge
```{r}
kfold_ridge_cv_qr <- function(formula, data, lambdas, k = 10){
  set.seed(123)
  folds <- caret::createFolds(
    data$Petal.Length,
    k = k,
    list = TRUE,
    returnTrain = FALSE
  )

  results <- data.frame(
    lambda    = lambdas,
    mean_rmse = NA_real_
  )

  for(li in seq_along(lambdas)){
    lam <- lambdas[li]
    rmse_fold <- numeric(length(folds))

    for(fi in seq_along(folds)){
      valid_idx <- folds[[fi]]
      train_idx <- setdiff(seq_len(nrow(data)), valid_idx)

      train_fold <- data[train_idx, , drop = FALSE]
      valid_fold <- data[valid_idx, , drop = FALSE]

      
      ridge_fit_qr <- ridgereg_qr(
        formula = formula,
        data    = train_fold,
        lambda  = lam
      )

      
      pred_valid_qr <- predict(ridge_fit_qr, newdata = valid_fold)

     d
      rmse_fold[fi] <- rmse(valid_fold$Petal.Length, pred_valid_qr)
    }

    results$mean_rmse[li] <- mean(rmse_fold)
  }

  results
}


cv_results_qr <- kfold_ridge_cv_qr(
  formula  = full_formula,
  data     = iris_train,
  lambdas  = lambda_grid,
  k        = 10
)

cv_results_qr

best_row_qr    <- cv_results_qr[ which.min(cv_results_qr$mean_rmse), ]
best_lambda_qr <- best_row_qr$lambda

best_lambda_qr
best_row_qr

ridge_best_qr <- ridgereg_qr(
  formula = full_formula,
  data    = iris_train,
  lambda  = best_lambda_qr
)

print(ridge_best_qr)
coef(ridge_best_qr)

ridge_train_pred_qr <- predict(ridge_best_qr, newdata = iris_train)
ridge_test_pred_qr  <- predict(ridge_best_qr, newdata = iris_test)

ridge_train_rmse_qr <- rmse(iris_train$Petal.Length, ridge_train_pred_qr)
ridge_test_rmse_qr  <- rmse(iris_test$Petal.Length,  ridge_test_pred_qr)

ridge_train_rmse_qr
ridge_test_rmse_qr

```
# =====================================================
# dplyr Vizualize Airport Delay
```{r}


library(ggplot2)
library(nycflights13)


head(nycflights13::flights)

delay_data <- nycflights13::flights |>
  dplyr::group_by(dest) |>
  dplyr::summarise(
    mean_delay = mean(arr_delay, na.rm = TRUE),
    .groups = "drop"
  ) |>
  dplyr::left_join(
    nycflights13::airports,
    by = c("dest" = "faa")
  ) |>
  dplyr::select(dest, mean_delay, lat, lon)

head(delay_data)


ggplot(
  delay_data,
  aes(x = lon, y = lat, colour = mean_delay)
) +
  geom_point(size = 3, alpha = 0.7) +
  labs(
    title = "Mean Arrival Delay by Airport (nycflights13)",
    x = "Longitude",
    y = "Latitude",
    colour = "Mean Delay (min)"
  ) +
  theme_minimal()


plot_obj <- visualize_airport_delays()
plot_obj
plot_obj + ggtitle("Mean Arrival Delay by Airport (custom title)")

```
# =====================================================
# Caret function
```{r}

set.seed(123)

ctrl <- caret::trainControl(
  method = "cv",    
  number = 10       
)

caret_model <- caret::train(
  form = full_formula,
  data = iris_train,
  method = "lm",     
  trControl = ctrl
)

caret_model

caret_model$results

caret_train_pred <- predict(caret_model, newdata = iris_train)
caret_test_pred  <- predict(caret_model, newdata = iris_test)

caret_train_rmse <- rmse(iris_train$Petal.Length, caret_train_pred)
caret_test_rmse  <- rmse(iris_test$Petal.Length,  caret_test_pred)

caret_train_rmse
caret_test_rmse
